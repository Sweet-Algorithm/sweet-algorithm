# 문제 조건 분석

- 입력: 첫째 줄에 명령의 수 N (1 ≤ N ≤ 10,000), 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다.
  - 주어지는 정수는 1~100,000. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.
- 출력: 한 줄에 하나씩 출력
- 스택 구현하기

---

# 설계

- push X: 정수 X를 스택에 넣는 연산이다.
- pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.
- size: 스택에 들어있는 정수의 개수를 출력한다.
- empty: 스택이 비어있으면 1, 아니면 0을 출력한다.
- top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.

⇒ 각각 함수로 분리해서 구현하기

⇒ 출력은 pop, size, empty, top의 경우에만 실행

---

# 트러블슈팅

## JS의 배열 참조 방식과 함수 내부에서의 재할당

- 문제 상황 : 함수 내부에서 변경된 `stack`이 외부에서 호출한 코드에 반영되지 않았습니다.
  ```jsx
  // 기존
  stack = stack.slice(0, stack.length - 1);

  // 수정
  stack.splice(-1, 1);
  ```
- **원인**
  1. **자바스크립트에서 배열 참조**
     - 자바스크립트에서 배열은 참조 타입이다. 즉, 배열을 다른 변수에 할당하면 두 변수는 같은 배열을 가리킨다.
     - 하지만 함수 내부에서 변수에 새로운 배열을 할당하면 함수 내부에서만 영향을 미치고, 외부에서는 변수에서 변경된 사항을 알 수 없다.

## console.log로 인해 시간초과가 나는 이유

- 매번 `return console.log()` 방식으로 했었는데 이런 경우 시간 초과가 날 수 있다.

1. **I/O 작업의 비용**
   - **I/O 작업은 단순한 메모리 연산보다 훨씬 더 많은 시간이 걸린다.** 특히, 많은 양의 데이터를 반복적으로 출력하는 경우, 각 출력 작업이 I/O 작업으로 처리되면서 성능 저하가 발생할 수 있다.
2. **문맥 전환**
   - console.log는 JavaScript 런타임에서 브라우저나 Node.js 환경으로 데이터를 전송한다. 이 과정에서 **문맥 전환(Context Switching)이 생기면서 추가 비용이 발생**한다.
3. **출력 버퍼**
   - **출력 버퍼링 문제**도 발생할 수 있다. 많은 양의 로그가 한 번에 출력되면, 출력 버퍼가 가득 차서 비우는 데 시간이 걸린다.
4. **동기/비동기 처리**
   - 대부분의 `console.log` 구현은 **동기적으로 작동**한다. 즉, 로그 출력이 완료될 때까지 다음 작업이 진행되지 않기 때문에, 특히 루프 내에서 빈번하게 호출될 경우 전체 성능에 큰 영향을 미친다.
